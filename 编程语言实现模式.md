# 《编程语言实现模式》
## 第1章 语言应用初探
走马观花式的介绍了一些模式和其应用场景，<br>
然后是用几个语言应用的例子来说明，语言应用都是大同小异的

## 第2章 基本解析模式
* 模式1：从文法到递归下降识别器————文法手动转化为解析器
    * 无法处理左递归
    * 一些文法现象会导致识别器不知道该调用那个方法
    * 有点弱鸡，因为都是if else 预读确定路线，一旦走错了会整条文法匹配失败

* 模式2：LL(1)递归下降词法分析器————字符流分解为Token
    * 词法分析的方法和模式1差不多，缺点也差不多
    * 由于token都是终结符，不会遇到左递归，不稳定的问题，走错路线的问题还有

* 模式3：LL(1)递归下降语法解析器————只根据当前输入字符来决定如何解析
    * 和模式2几乎一样，最大的问题，是一条文法可能会递归定义自另一条文法，导致预读的规则（向前看集合）复杂
    * 向前看集合不能有重叠（有重叠意味着可能被其它规则截胡，但这个规则不一定能完全匹配，匹配不了就挂掉了，因为没有回溯）
    * 上面这点可以通过改写文法来改善

* 模式4：LL(k)递归下降语法解析器————模式3的增强，向前看k个输入字符来决定如何解析
    * 模式3的增强，解决了向前看集合不能有重叠的问题（如果两条子文法的第一个token是一样的，那读到能决定路径就好）
    * k一般不能为无限大，因为要应付那些无限的字符流



## 第3章 高阶解析模式
* 模式5：回溯解析器
    * 拥有LL解析器的最强解析能力，但是还是不能应付某些文法（左递归）
    * 原理是进行匹配前记录位置，在成功匹配后清空缓存，匹配失败跳回起始
    * 慢
* 模式6：记忆解析器
    * 模式5慢的原因是，不同路径的开头部分会有相同的部分，模式5把匹配过的它们给丢掉了
    * 这个模式用一个缓存存储了，坐标和坐标匹配过的文法
* 模式7：谓词解析器
    * 选路径的时候通过一些文法以外的信息来判断走向
    * 一般通过词汇表



## 第4章 从语法树构建中间表示
* 模式8：解析树
    * 内节点是规则名，叶节点是词法单元
    * 里面实在是太多无用的东西了，只需要保留操作符，和被操作的部分，即可提高解析速度
* 模式9：同构AST
    * 树上的节点类型都一样
* 模式10：规范化异形AST
    * 节点的类型不同（说是不同但是都有同一个基类）
    * 规范化的子节点列表（子元素只能通过children[0]这种方式来访问）
* 模式11：不规则的异形AST
    * 节点的类型不同（说是不同但是都有同一个基类）
    * 子节点保存到不同名称的字段里面（本书所说的异形树）
        * 或另外外添加getter来访问children[i]（我所知道的异形树）


## 第5章 遍历并改写树形结构
* 模式12：内嵌遍历器
    * 本书所说的异形树专用
    * 超麻烦（一个复杂语言里面的类少说几百个）
* 模式13：外部访问者
    * 访问者模式
    * 超麻烦（同上）
* 模式14：文法访问者
    * 是一个使用了ANTLR工具的模式（没有普适性）
    * 工具自动生成大部分的遍历器，可以给特定的文法添加特殊的遍历器
* 模式15：模式匹配者
    * 只对特定的模式起作用
    * 用于在遍历的过程中对树的项进行该写