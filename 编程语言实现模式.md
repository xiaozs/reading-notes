# 《编程语言实现模式》
## 第1章 语言应用初探
走马观花式的介绍了一些模式和其应用场景，<br>
然后是用几个语言应用的例子来说明，语言应用都是大同小异的

## 第2章 基本解析模式
* 模式1：从文法到递归下降识别器————文法手动转化为解析器
    * 无法处理左递归
    * 一些文法现象会导致识别器不知道该调用那个方法
    * 有点弱鸡，因为都是if else 预读确定路线，一旦走错了会整条文法匹配失败

* 模式2：LL(1)递归下降词法分析器————字符流分解为Token
    * 词法分析的方法和模式1差不多，缺点也差不多
    * 由于token都是终结符，不会遇到左递归，不稳定的问题，走错路线的问题还有

* 模式3：LL(1)递归下降语法解析器————只根据当前输入字符来决定如何解析
    * 和模式2几乎一样，最大的问题，是一条文法可能会递归定义自另一条文法，导致预读的规则（向前看集合）复杂
    * 向前看集合不能有重叠（有重叠意味着可能被其它规则截胡，但这个规则不一定能完全匹配，匹配不了就挂掉了，因为没有回溯）
    * 上面这点可以通过改写文法来改善

* 模式4：LL(k)递归下降语法解析器————模式3的增强，向前看k个输入字符来决定如何解析
    * 模式3的增强，解决了向前看集合不能有重叠的问题（如果两条子文法的第一个token是一样的，那读到能决定路径就好）
    * k一般不能为无限大，因为要应付那些无限的字符流



## 第3章 高阶解析模式
* 模式5：回溯解析器
    * 拥有LL解析器的最强解析能力，但是还是不能应付某些文法（左递归）
    * 原理是进行匹配前记录位置，在成功匹配后清空缓存，匹配失败跳回起始
    * 慢
* 模式6：记忆解析器
    * 模式5慢的原因是，不同路径的开头部分会有相同的部分，模式5把匹配过的它们给丢掉了
    * 这个模式用一个缓存存储了，坐标和坐标匹配过的文法
* 模式7：谓词解析器
    * 选路径的时候通过一些文法以外的信息来判断走向
    * 一般通过词汇表



## 第4章 从语法树构建中间表示
* 模式8：解析树
    * 内节点是规则名，叶节点是词法单元
    * 里面实在是太多无用的东西了，只需要保留操作符，和被操作的部分，即可提高解析速度
* 模式9：同构AST
    * 树上的节点类型都一样
* 模式10：规范化异形AST
    * 节点的类型不同（说是不同但是都有同一个基类）
    * 规范化的子节点列表（子元素只能通过children[0]这种方式来访问）
* 模式11：不规则的异形AST
    * 节点的类型不同（说是不同但是都有同一个基类）
    * 子节点保存到不同名称的字段里面（本书所说的异形树）
        * 或另外外添加getter来访问children[i]（我所知道的异形树）


## 第5章 遍历并改写树形结构
* 模式12：内嵌遍历器
    * 本书所说的异形树专用
    * 超麻烦（一个复杂语言里面的类少说几百个）
* 模式13：外部访问者
    * 访问者模式
    * 超麻烦（同上）
* 模式14：文法访问者
    * 是一个使用了ANTLR工具的模式（没有普适性）
    * 工具自动生成大部分的遍历器，可以给特定的文法添加特殊的遍历器
* 模式15：模式匹配者
    * 只对特定的模式起作用
    * 用于在遍历的过程中对树的项进行该写

## 第6章 记录并识别程序中的符号
这一章的内容比较简单没有啥好说的

* 模式16：单作用域符号表
* 模式17：嵌套作用域符号表

## 第7章 管理数据聚集的符号表
* 模式18：数据聚集的符号表
    * 用于struct、a.b这种语法
    * 是15、17的组合使用
* 模式19：类的符号表
    * 和18没有多大区别，要注意a.b语法要沿着继承链查找

同时，这里描述了一个前向引用的问题
    * 所谓的前线引用就是先引用后声明的意思
    * 可以通过2次遍历ast来实现
        * 第一次 生成符号表
        * 第二次 解析符号引用
    * 有可能只是部分支持前向引用，这种情况下，可以通过在解析时比对在符号表中的前后顺序，来判定是否非法


## 第8章 静态类型检查
* 模式20：计算表达式类型
    * 采用和14、15类似的方法，
    * 在建立了符号表后，给AST上的节点推断类型
* 模式21：自动类型提升
    * 通过对比操作符两端的操作数的类型大小，来在AST节点上做上类型提升的标记
* 模式22：检查类型安全
    * 建立在20已经给AST加上类型信息的基础上
    * 把出错信息保存数组里
* 模式23：多态类型检查
    * 基于22
    * 主要区别时进行类型检查是让有继承关系的类型过关

其实我觉得在第5章开始之后都只是写树遍历而已：
* 遍历生成符号表
* 遍历给个别节点添加类型提升标记
* 遍历进行类型检查
* 不排除还有其它乱七八糟的遍历
    * 模式15是其中一个

以上几个步骤，除了生成符号表要占用一次遍历外，<br>
其余步骤可以合在一次的遍历里，<br>
应该可以用一些面向对象和函数式的方式来进行解耦设计


## 第9章 构建高级解释器
* 模式24：语法制导解析器
    * 适用于基本上是一连串的指令或简单声明语句的语言
    * 原理是匹配某一文法后马上执行特定的操作
* 模式25：基于树的解释器
    * 基于之前的AST树
    * 用12或13，为节点类添加eval方法
    * 因为使了AST树，可以对节点进行修改提高效率，还可以提高灵活度


## 第10章 构建字节码解释器

