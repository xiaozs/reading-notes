# 《Dart编程语言》
## 第1章 简介
```
先来一波设计准则吧：
```
* 都是对象，包括数字之类的基本类型，也就是说不用考虑拆装箱。
* 面向接口，所有类都实现了一个拥有该类所有方法属性的隐含接口。（貌似ts也是这样，貌似所有支持鸭式辨型的都这样）
* 没有final，可重写所有东西。（更scala完全相反了，我觉得不太好）
* 完全封装，属性的读写实际上的是通过方法。（只要支持getter、setter的语言都没所谓了）
* 构造函数允许缓存。（也就是说，与其说是构造函数，更像是一个工厂函数）

```
一些奇葩特性：
```
* 整数可以无限大小，只要你内存装得下。

```
一些挺有意思的特性：
```
* 函数命名不用function关键字
* 支持操作符重载

## 第2章 对象、接口、类与mixin
* getter、setter的写法和js一样，不过这里可以用=>箭头函数

* 用final声明字段其实相当于只设置getter
* 用```obj is interfaceName```来判断是否实现了某个接口（而不是判断是不是某个类的实例，我觉得这一点特别好）
* 构造函数调用父构造函数的方法类似于C++，（但我更喜欢类似于C#那种）
* factory这个就是第一章提到过的特性<br>
（目的应该就是能够统一构造函数和工厂函数的接口，使得能在不修改原有代码的基础上用工厂替代一般的构造函数，<br>
使其能做到，缓存啊这些功能，这个是传统的语言做不到的）
* noSuchMethod方法，由于Dart实现了完全封装（所有发给对象的消息都是通过方法调用），所以可以对所用方法查询做拦截<br>
其中noSuchMethod这个钩子方法应该是抄的Ruby。（用处应该也跟Ruby类似，用来实现proxy）
* 用const可以声明常量对象，和常量构造函数，产量构造函数要用const替代new来调用（老实说，我搞不懂这个有什么用）
* mixin：

    1.先来说明一下语法<br>
    ```class NewClassName = OldClassName with MixinName1, MixinName2```<br>
    在dart中所谓的mixin其实是一个抽象类<br>
    通过with关键字来修饰原有的类，可以生成一个匿名类<br>

    2.然后是使用理由<br>
    传统的面向对象添加新类型很容易，但是添加新功能很难，（因为要修改所有实现的该接口的类）<br>
    传统的面向过程（if else判断类型执行对应操作）添加新功能很容易，但是添加新类型很难，（因为要修改原来的if else函数）<br>
    使用mixin的话可以在原有的类型上动手动脚，而不用修改原有类型的代码<br>
    而且因为每个mixin的粒度较小，可以避免继承带来的问题（想要香蕉，但是得到的是手握香蕉的猩猩和森林）

## 第3章 库
* 顶层：<br>
dart中没有嵌套类，所以所有类都在顶层，

* 隐私：<br>
以下划线（_）开头的成员是库私有的，只能在库内部访问。<br>
像C#那种会有更加乱七八糟的访问修饰符。<br>
像ts那种又连个friend都没有。<br>
总之什么是最佳实践，我也不是很清楚。

* 导入：<br>
是后端语言一贯的导入一个库名，就导入了库里面的所有可访问类型<br>
这样的做法容易导致命名冲突，为了避免冲突又衍生出show、hide两个关键字<br>
（所以我比较喜欢js里面的引入方法，虽然比较麻烦，但是如果有IDE智能导入这个不是问题）<br>

* 导出：<br>
导出可以用（倒不如说应该用）show关键字，达到js的导出的类似结果

```
联系一下js的导入系统（npm参与的那一套），
npm2因为依赖文件树形摆放的原因，可以让依赖程序同一个包的不同版本，但是window上路径过长，
npm3扁平化却又失去了这个特点，
我觉得，把同一个包的不同版本放在同一个文件夹下，以版本号区分它们就可以同时得到以上两个好处了。

以js的导入方式 import {xxx} from "packageName/path/to/file";
相当于包内有命名空间（和文件空间一致）这个玩意了，
由于js缺少和包相关的访问修饰符，
是应该保留这种让能用的类散落在每个文件中，(这样不知道那个是提供给外部使用的)
还是把提供给外部的类型在main文件里面重新导出，(这样的话命名空间就被削掉了，如果有冲突还要重新命名)
这个问题是个谜。
```

* 钻石导入：<br>
这个问题同样是冲突造成的。

* 延迟加载：<br>
这个语法上比较麻烦 ，js的await import会更好。
```dart
import "xxx.dart" deferred as rarelyUsed;
rarelyUsed.loadLibrary().then(onLoad);
```


## 第4章 函数
```
只记录一下有意思的地方：
```
* 级联：
```dart
var address = new Address.of("Freddy Krueger");
address.setStreet("Elm", "13a");
address.city = "Carthage";
address.state = "Eurasia";
address.zipCode(66666, extend: 66666);

//相当于
new Address.of("Freddy Krueger")
    ..setStreet("Elm", "13a")
    ..city = "Carthage"
    ..zipCode(66666, extend: 66666);
```

* Function类
```
任何声明了call方法的类，都隐含地实现了Function类。
它们的实例都可以，用 obj() 来调用对应的call方法，

我觉得它们这样搞实在是太难懂了，
直接来一个运算符重载，重载()就直观多了。
不过能用就好，是一个非常好的特性。
```

* 生成器：
```
虽然在前言里面，作者大大咧咧的说了，
dart是唯一同时支持
同步/异步函数、
同步/异步生成器
四种模式的语言，
但是在我仔细看过以后，js、ts已经实现了，
语法上面说来大同小异，
甚至在dart里面还多了个sync同步关键字
```


## 第5章 类型
* Dart不支持基于类型的重载
* 用dynamic关键字来达到类型ts里面的any的功能
* 还有一些父类型可以赋值给子类型的怪功能（只是为了从map里面取出东西的时候不用强制类型转换）
* 然后探讨了泛型存在的问题
    * 协变
    * 函数的子类型问题
* 一些特性
    * 实现了call方法的对象会被视为函数（我觉得这个功能用运算符重载实现会更好）
    * 给@proxy留了后门，便于编写Proxy（不用每一个方法都写一个转发）
* 非严格的类型系统
    * 泛型的协变
    * 可赋值性规则中的类型向下转换（上面提到的怪功能）
    * 函数类型的可赋值性
    * 隐私与接口类型的相互作用<br>
    （这一点说明了ts里面impl一个类型时为啥要连私有属性都要实现的原因）<br>
    （因为如果不这样做，那么类型的实现过程中只能通过this访问私有属性）<br>
    （这个比较复杂，具体可以看书）


## 第6章 表达式和语句
这一章是唯一和其它编程语言介绍书差不多的，也没有什么特别的东西

