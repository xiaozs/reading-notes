# 《Dart编程语言》
## 第1章 简介
```
先来一波设计准则吧：
```
* 都是对象，包括数字之类的基本类型，也就是说不用考虑拆装箱。
* 面向接口，所有类都实现了一个拥有该类所有方法属性的隐含接口。（貌似ts也是这样，貌似所有支持鸭式辨型的都这样）
* 没有final，可重写所有东西。（更scala完全相反了，我觉得不太好）
* 完全封装，属性的读写实际上的是通过方法。（只要支持getter、setter的语言都没所谓了）
* 构造函数允许缓存。（也就是说，与其说是构造函数，更像是一个工厂函数）

```
一些奇葩特性：
```
* 整数可以无限大小，只要你内存装得下。

```
一些挺有意思的特性：
```
* 函数命名不用function关键字
* 支持操作符重载

## 第2章 对象、接口、类与mixin
* getter、setter的写法和js一样，不过这里可以用=>箭头函数

* 用final声明字段其实相当于只设置getter
* 用```obj is interfaceName```来判断是否实现了某个接口（而不是判断是不是某个类的实例，我觉得这一点特别好）
* 构造函数调用父构造函数的方法类似于C++，（但我更喜欢类似于C#那种）
* factory这个就是第一章提到过的特性<br>
（目的应该就是能够统一构造函数和工厂函数的接口，使得能在不修改原有代码的基础上用工厂替代一般的构造函数，<br>
使其能做到，缓存啊这些功能，这个是传统的语言做不到的）
* noSuchMethod方法，由于Dart实现了完全封装（所有发给对象的消息都是通过方法调用），所以可以对所用方法查询做拦截<br>
其中noSuchMethod这个钩子方法应该是抄的Ruby。（用处应该也跟Ruby类似，用来实现proxy）
* 用const可以声明常量对象，和常量构造函数，产量构造函数要用const替代new来调用（老实说，我搞不懂这个有什么用）
* mixin：

    1.先来说明一下语法<br>
    ```class NewClassName = OldClassName with MixinName1, MixinName2```<br>
    在dart中所谓的mixin其实是一个抽象类<br>
    通过with关键字来修饰原有的类，可以生成一个匿名类<br>

    2.然后是使用理由<br>
    传统的面向对象添加新类型很容易，但是添加新功能很难，（因为要修改所有实现的该接口的类）<br>
    传统的面向过程（if else判断类型执行对应操作）添加新功能很容易，但是添加新类型很难，（因为要修改原来的if else函数）<br>
    使用mixin的话可以在原有的类型上动手动脚，而不用修改原有类型的代码<br>
    而且因为每个mixin的粒度较小，可以避免继承带来的问题（想要香蕉，但是得到的是手握香蕉的猩猩和森林）

## 第3章 库
* 顶层：<br>
dart中没有嵌套类，所以所有类都在顶层，

* 隐私：<br>
以下划线（_）开头的成员是库私有的，只能在库内部访问。<br>
像C#那种会有更加乱七八糟的访问修饰符。<br>
像ts那种又连个friend都没有。<br>
总之什么是最佳实践，我也不是很清楚。

* 导入：<br>
是后端语言一贯的导入一个库名，就导入了库里面的所有可访问类型<br>
这样的做法容易导致命名冲突，为了避免冲突又衍生出show、hide两个关键字<br>
（所以我比较喜欢js里面的引入方法，虽然比较麻烦，但是如果有IDE智能导入这个不是问题）<br>

* 导出：<br>
导出可以用（倒不如说应该用）show关键字，达到js的导出的类似结果

```
联系一下js的导入系统（npm参与的那一套），
npm2因为依赖文件树形摆放的原因，可以让依赖程序同一个包的不同版本，但是window上路径过长，
npm3扁平化却又失去了这个特点，
我觉得，把同一个包的不同版本放在同一个文件夹下，以版本号区分它们就可以同时得到以上两个好处了。

以js的导入方式 import {xxx} from "packageName/path/to/file";
相当于包内有命名空间（和文件空间一致）这个玩意了，
由于js缺少和包相关的访问修饰符，
是应该保留这种让能用的类散落在每个文件中，(这样不知道那个是提供给外部使用的)
还是把提供给外部的类型在main文件里面重新导出，(这样的话命名空间就被削掉了，如果有冲突还要重新命名)
这个问题是个谜。
```

* 钻石导入：<br>
这个问题同样是冲突造成的。

* 延迟加载：<br>
这个语法上比较麻烦 ，js的await import会更好。
```dart
import "xxx.dart" deferred as rarelyUsed;
rarelyUsed.loadLibrary().then(onLoad);
```