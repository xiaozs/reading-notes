# 《Haskell并行与并发编程》
## 第1章 绪论
并行性和并发性的概念


## 第2章 并行基础：Eval Monad
```haskell
runEval $ do
   a <- rpar(f x)
   b <- rpar(f y)
   rseq a
   rseq b
   return (a, b)
```
类似于
```javascript
async () => {
    let aPromise = (async ()=> f(x))();
    let bPromise = (async ()=> f(y))();

    let a = await aPromise;
    let b = await bPromise;

    return (a, b);
}()
```

同时也介绍了haskell的惰性求值系统的原理


## 第3章 求值策略
函数式的策略模式



## 第4章 数据流并行：Par Monad
类似于channel和go块<br>
可以参考《七周七并发模型》第6章 通信顺序进程



## 第5章 Repa数据并行编程
使用Repa库，以DSL的方式编写CUDA或OpenCL代码。



## 第7章 并发基础：线程和MVar
MVar是一个对于锁的抽象<br>
可用于共享状态



## 第8章 重叠I/O
通过上一章的内容来实现异步的方式<br>
异常的处理方式<br>
不同于js的异步，这里的异步是会阻塞主线程的。

## 第9章 线程的取消和超时
* 线程取消：
    * 查询是否已被取消：<br>
    存在程序员忘记足够频繁地进行查询的危险，这样线程将变得响应迟钝
    * 线程取消是异步发生的：<br>
    则需要对代码中修改状态的关键部分加以保护

完全地异步取消是Haskell唯一合理的默认选择<br>
线程取消应该和异常相似(可以进行try catch finally等处理)<br>

这本书里通过随时抛出一个异常来实现线程的取消，为了不让异常在奇怪的地方抛出导致修改状态不一致，<br>
通过mask函数捕获异常，让异常在特定的地方重新抛出

## 第10章 软件事务内存
* 和MVar的对比
    * 和MVar相比，STM在多个方面有质的改进：可组合的原子操作，可组合的阻塞操作以及简单的错误处理
    * MVar的一个优势是比STM快
    * 和STM相比MVar确实有一个重要的优点：公正性（阻塞的线程会以FIFO（先进先出）的顺序唤醒）
    * 

* STM原理：
    * STM事务通过累积事务中到目前为止发生的readTVar和writeTVar操作的日志来工作。<br>
    日志有3个用途：
        * 通过将writeTVar操作保存为日志而非立即应用到主内存，可以很容易地抛弃事务的效果，抛掉日志即可。因此，中止事务有固定的少量开销
        * 每个readTVar必须遍历日志，检查TVar是否之前有writeTVar写入。因此，readTVar操作对日志的长度是O(n)的复杂度。
        * 由于日志记录了所有的readTVar操作，所以可以用于找到事务中所有需要读取的TVar，为了实现retry需要知道该信息
    * 因为任何对事务访问的TVar的改变必须触发当前事务的重新运行，而操作retry使用事务日志来找出这些TVar。因此，每个TVar都有一个线程监视列表，当TVar修改后，列表上的线程应该唤醒，而retry将当前线程加到当前事务所有读取的TVar的监视列表中。因此，retry对事务中读取的TVar数量的复杂度是O(n)。当事务提交后，若任何修改的TVar有监视列表，则列表上所有的线程都会被唤醒。

## 第11章 高级并发抽象
前几章开发了Async接口，用于进行异步操作并等待结果。<br>
本章将回顾该接口并扩展出一些更精巧的功能。<br>
特别是会提供一种创建Async的方式，使之能在其父线程异常中止后自动取消，<br>
并使用该方式来构建可组合性更强的功能。

这样做的目的是获得构建线程树的能力，<br>
这样无论由于何种原因导致线程崩溃，都会发生两件事情：<br>
任何其子线程将自动停止，以及通知其父线程。<br>
因此线程树总是自底向上崩溃的，而不会由于偶然原因剩下继续运行的线程。<br>
此外，通过异常处理，所有线程在其崩溃时都有机会进行清理工作。