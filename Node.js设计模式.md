# 《Node.js设计模式》

## 第1章 欢迎来到Node.js平台

```
我终于搞懂了什么是Reactor模式了，说的就是js的那一套事件循环。
```

## 第2章 Node.js基础设计模式

```
讲述了node的回调模式：
1. 函数要统一为异步/同步，不能半异步半同步，这一点在那本《JavaScript异步编程：设计快速响应的网络应用》里面也有提到。
2. 谈论了回调模式中的异常捕捉和抛出方式（全部都要手动捕捉和抛出）（这一点如果是用了async函数会有很大的改善）
3. 对于未捕捉到的异常，可以用process.on("uncaughtException",(err)=>{})来捕捉

模块加载的模式：
1. cmd的实现原理，在《深入浅出Node.js》里面也说过。
2. module.exports和exports的区别，这个也在上面那本里面说过了。
3. require函数是同步的。（我记得这个被作为面试题，被某位大佬在zhihu上提出过）（答案是：在代码加载这一块上异步带来的优点比不过它带来的复杂性）
4. require模块的解析方式（require.resolve方法）
5. 模块缓存（require.cache）
6. 讨论了循环应用带来的问题（不知道为什么这个竟然没有抛出）
7. new.target语法的作用，new.target用于判断是否使用new来调用的当前函数

观察者模式：
1. 和之前讨论的一样，回调中的异常要自己手动捕获、抛出。
2. 自带的EventEmitter如果不绑定error事件，一旦遇到没捕获异常会退出程序
3. 讨论了同步、异步事件，其实就是是否setTimeout来调用emit方法的不同。
4. EventEmitter与回调（讨论了事件和回调的不同：取异步操作的结果时用回调，其它用事件；事件一对多，事件还可以对多种类型事件，回调一对一；）
```

```
总体来说这一章书的收获还是挺大的。
```

## 第3章 异步控制流模式之回调函数

```
如何避免地狱回调，就是把匿名的回调函数，起个名，拉其它地方就好了。
用es6就更简单了。

这里还有一种手写的方法，我也是醉了。
1. 顺序执行
2. 并行执行
3. 有限制的并行执行

介绍了用async库来重写的上面3个模式
```

## 第4章 异步控制流模式之ES2015+

```
介绍了用Promise来重写的上面3个模式

接受了generator相关语法、api
用thunk配合generator重写了上面3个模式，
这一套东西实在是太复杂了，之后还要重新复习一遍thunk配合generator的原理。

最后是async/await，
这一套的实现原理其实和上面的thunk配合generator是一致的，
把thunk换成Promise，用语法关键字来避免generator的api的显式调用，
async关键字为转译器表明了generator转换的地方。
```

## 第5章 流编程
```
介绍了缓冲和流的区别

流stream是EventEmitter类的实例。
抽象类：
stream.Readable
stream.Writable
stream.Duplex
stream.Transform
```
//todo

## 第6章 设计模式
* 工厂模式：允许我们不暴露创建对象的构造函数，避免其被继承或修改。
* 揭示构造函数：（例子是Promise的构造函数，限制了resolve和reject只能在回调里）
* 代理模式：实现了与本体对象相同的接口，代理对象可以拦截所有或部分对本体执行的操作，补充或增强其行为。
    * 数据验证
    * 安全性（授权检查）
    * 缓存
    * 延迟初始化（延迟本体的实例化，等到真的需要时才new出来）
    * 日志
    * 远程对象代理
* 装饰者模式：类似于代理模式，不过不是为了补充或增强其行为，而是为了添加新功能（新方法）。
* 适配器模式
* 策略模式
* 状态模式：是策略模式的一种变形，会根据上下文状态而改变策略。
* 模板模式：类似于策略模式，策略模式允许我们动态指定算法，模板模式在定义具体类时已经确定了算法。
* 中间件模式：express中间件那一类
* 命令模式：回调其实就是最简单的命令模式，复杂的命令模式还可以做到，历史记录、撤销这些功能。

## 第7章 连接模块
* 硬编码的依赖：一般的做法，没有什么好说的
* 依赖注入：在对象生成时，通过参数注入依赖；或者对象生成后通过属性复制来注入依赖。<br>
（属性注入更强大，因为可以循环依赖，但是循环依赖不是好实践）
* 服务定位器：这个是下面的劣等替换，不说
* 依赖器注入容器：一个工厂函数，和它对应的注册器；<br>
只要做好注册，调用工厂函数，就是自动计算依赖生成对象<br>
不通过注册器，也可以用手动注入的方式生成对象。

## 第8章 通用JavaScript的Web应用程序
说的是同构相关的知识，大部分可以在《同构JavaScript应用开发》中找到原理和实践工具
这里介绍了一些特殊的技巧：
* 构建时代码分支：通过使用webpack内置的DefinePlugin和uglifyJsPlugin插件生产不同环境的代码
* 模块交换：通过使用moduleReplacementPlugin替换require函数的寻址
* 用于跨平台开发的设计模式：
    * 策略和模板：定义公共部分，差异部分由运行时、构建时代码分支替代
    * 适配器
    * 代理：这里举了一个例子如果浏览器上想要使用fs模块，可以通过ajax调用后台来使用。
    * 观察者
    * 依赖注入：通过注入替换模块的实现

## 第9章 高级异步编程技巧
* 预初始化队列：对于那些要异步启动的模块，为了不丢失用户请求，<br>
可以给原有模块做包装，
在它初始化的时候把请求用队列存储起来，<br>
模块准备好后，把重新调用原有模块<br>
(mongoose就使用了这个模式)
* 异步请求批处理：如果在调用api时已经有另一个相同的请求挂起，<br>
将把回调添加到队列中。<br>
当异步操作完成时，其队列中的所有回调将一次被调用。<br>
(当api已经很快，快到队列中没有几个回调的时候，这个模式起到的作用较低；反之，api很慢时很有用)
* 异步请求缓存：缓存，应该和上一个模式一起使用，并且放在上一个模式后面一层。
    * 使用**最近最少使用算法（LRU）**来防止内存大量消耗
    * 当程序分布在多个进程中时，可能会导致每个服务器返回不同结果，解决办法是使用共享存储，例如redis
* 使用promise进行批处理和缓存：promise能胜此任的两个原因：
    * 多个then监听器可以附加到相同的promise（相当于批处理）
    * then最多只能被调用一次（相当于缓存）
* 运行CPU绑定的任务：其实就是用setTimeout来处理大运算量的算法，不用它一直占用线程，node里面用的是setImmediate。
    * 不能用nextTick，会导致io饥饿
* 使用多线程：
    * 要使用线程池，因为启动新线程很耗时，同时线程池限制了线程数量能够抵御DOS攻击

## 第10章 扩张与架构模式
拓展立方体模型的三个维度：
* x轴：克隆————集群
    * 弹性和可用性（子进程挂了，可以由父进程拉起来）
    * 零停机重启（保证重启时有提供服务的子进程）
    * 带来的了问题（如何共享状态），解决方法：
        * 共享数据存储（数据库、redis等）
        * 黏性负载均衡：绑定客户端和特定实例（通过cookie或ip哈希），缺点是特定实例挂了，和它绑定的客户端也会出问题
    * 动态负载均衡：启动一个服务用来注册、解注册，真正进行对请求进行处理的服务在启动时把ip、port、类型注册到该服务上，负载均衡器做转发。
    * 对等负载均衡：将负载均衡器做到客户端上
* y轴：服务功能分解————微服务
    * API代理：服务器上有个反代，把url代理到对应的为服务上（这样做，客户端要调很多接口，一来一回的也很慢）
    * API编排：包装过微服务，将多个微服务操作组合成一个业务接口，再提供给客户端（容易形成上帝类型）
    * 与消息代理集成：为了解决上帝类型的问题，各个微服务只通过事件总线进行沟通（只响应或发出事件）来进行解耦
* z轴：分割数据分区————数据库分片

## 第11章 消息传递与集成模式
集成分布式应用程序的两种主要技术：
* 共享存储作为所有信息的中心协调器和保管人
* 使用消息在系统节点上传播数据、事件和命令

本章讨论了一下主题：
* 消息系统的基本原理
    * 传播的方向：单向、请求/应答交换
    * 消息的目的
    * 消息的时间：同步、异步（异步可以使用消息队列）
    * 消息的传递：对等或基于代理（通过代理可以提供更多高级功能：持久性队列、路由、消息转换、监控等）
* 发布/订阅模式
    * 使用redis作为消息代理
    * 使用zmq对等发布/订阅（这里有一个细节：zmq采用了重连机制，所以一开始在其它节点都没有上线的时候也不会报错）
    * 持久订阅者（消息队列）：
        * 服务质量：
            * 最多一次（消息不会持续、并且传递不被确认）
            * 至少一次（保证消息至少被接收一次、可能发生重复）
            * 恰好一次
* 管道和任务分配模式
    * zmq扇出/扇入模式
    * 使用AMQP实现管道和竞争消费者模式
* 请求/应答模式
    * 单向通道之上：关联标识符（用于识别请求和其应答的id）
    * 多个通道或队列：返回地址（用于识别不同通道的标识）