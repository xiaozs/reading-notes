# 《JavaScript函数式编程指南》
## 第1章 走近函数式

```
大部分是理论叙述，
尽量挑一下有指导性的：
```

函数式编程的目标是使用函数来**抽象作用在数据之上的控制流与操作**，从而在系统中**消除副作用**并**减少对状态**的改变

基本概念:
* 声明式编程
* 纯函数
* 引用透明（这个我看了一下定义，不是和纯函数一个意思么？）
* 不可变性

函数式编程的优点：
* 促使将任务分解成简单的函数
* 使用流式的调用链来处理数据
* 通过响应式范式降低事件驱动代码的复杂性



## 第2章 高阶JavaScript

```
下面的这两段话比较好的说明了两种编程范式之间的差异、思路。
```

面向对象的应用程序大多是命令式的，因此在很大程度上依赖于使用基于对象的封装来保护其自身和继承的可变状态的完整性，再通过实例方法来暴露或修改这些状态。
其结果是，对象的数据与其具体的行为以一种内聚的包裹的形式紧耦合在一起。而这就是面向对象程序的目的，也正解释了为什么对象是抽象的核心。

再看函数式编程，它不需要对调用者隐藏数据，通常使用一些更小且非常简单的数据类型。
由于一切都是不可变的，对象都是可以直接拿来使用的，而且是通过定义在对象作用域外的函数来实现的。
换句话说，数据与行为是松耦合的。函数式代码使用的是可以横切或工作于多种数据类型之上的更加粗粒度的操作，而不是一些细粒度的实例方法。
在这种范式中，函数成为抽象的主要形式。

```
之后还介绍了一些将函数式和面向对象结合起来的方法：
```
1. 对象作为不可变的数据结构
2. 将方法提取为函数，对象作为参数

```
这个方法好不好用不好说，
1. 因为数据和方法分离了，所以调用更麻烦了。
2. 但是同一个函数可以应付更多的符合同一接口的对象了。
3. 数据失去了封装，失去了private、protect，全变成public了，
   虽然说因为不变性变得没必要了，但是我总觉得的个前提有问题。
4. 虽然可以用mixin来解决1的问题，同时获得2的好处。
   但是类型没有了封装性，也不会存在非公开的方法了，
   这个始终困扰着我。
```

||函数式|面向对象|
|---|---|---|
|组合单元|函数|对象（类）|
|编程风格|声明式|命令式|
|数据和行为|独立且松耦合的纯函数|与方法紧耦合的类|
|状态管理|将对象视为不可变的值|主张通过实例方法改变对象|
|程序流控制|函数与递归|循环与条件|
|线程安全|可并发编程|难以实现|
|封装性|因为一切都是不可变的，所以没有必要|需要保护数据的完整性|

## 第3章 轻数据结构，重操作
```
几乎所有函数式编程的书都会说道的三板斧：
map、filter、reduce

还说了些：
链式编程、惰性计算、尾递归相关知识

没学到什么
```

## 第4章 模块化且可重用的代码
* 方法链接：方法与所属的对象紧紧地耦合在一起
* 管道（函数组合）：没有上述问题

还介绍了一些：
1. 元组（不可变、避免创建临时类型、避免创建异构数组）
2. 柯里化（用于创造函数工厂，生成参数列表较少的函数，提高易用性；本质是自动化的部分应用）
3. 部分应用（惰性函数绑定）

point-free编程：一种函数式编程风格，用管道组合多个单参数函数。

使用函数组合子管理程序控制流：
1. identity：```(it) => it```
2. tap：```(fun) => (it) => { fun(); return it;}``` :用于将无返回的函数嵌入到管道里面。
3. alt：```(fun1, fun2) => (it) => (fun1(it) || fun2(it))```：函数式的if
4. seq：```(...funs) => (it) => funs.forEach(fun => fun(it))```：没有返回值，作为终结技或配合tap使用。
5. join：```(join , fun1, fun2) => (it) => join(fun1(it), fun2(it))```

## 第5章 针对复杂应用的设计模式
过程式存在的问题：
1. 函数式程序不应抛出异常
2. 空值（null）检查问题

函数式使用Functor和Monad：
1. Functor：是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构
2. Monad：和Functor 类似，但在处理某些情况时可以带来一些特殊的逻辑（忽略异常值）。

使用Maybe Monad 和Either Monad 来处理异常。

函数式语言采用了Maybe来包装异常和返回值，<br>
swift更是统合了这两种语法

之后还另外阐述了函数组合带来的好处：
1. 更容易的日志实现
2. 惰性
3. 在组合的最后进行错误处理
