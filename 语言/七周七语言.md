# 《七周七语言》
## 第1章 简介
介绍了一点基本情况

## 第2章 Ruby
* 动态类型
* mixin
* 元编程：
    * 开放类（可以做到类似于拓展方法的东西）
    * method_missing（可用于实现代理）
    * 模块（类似于宏）


## 第3章 Io
* 原型继承（和js机制一样）
* 消息和消息反射：<br>
大部分语言都将参数作为栈上的值传递，<br>
首先计算参数的每个值，然后把这些值放到栈上<br>
Io传递的是消息本身和上下文，再由接受者对消息求值
* 通过运算符重载，和消息反射，可以轻而易举地建立DSL

* 并发：<br>
通过用@调用方法，<br>
该方法会自动变为异步方法，并返回future，<br>
调用异步方法的对象会成为actor<br>
访问future会自动阻塞



## 第4章 Prolog
* 逻辑编程语言

* 擅长：
    * 自然语言处理
    * 游戏
    * 语义网
    * 人工智能
    * 调度
* 不足：
    * 功用（非通用语言）
    * 超大数据集合
    * 严重依赖递归



## 第5章 Scala
* trait（类似于mixin）
* xml内置支持
* actor




## 第6章 Erlang
* actor
* OTP库（监控、重启actor）




## 第7章 Clojure
* 代码即是数据，可以通过宏对代码进行改写

* 第三天：一瞥魔鬼（并发变量修改）<br>
可以参考《七周七并发模型》的第4章
    * STM（软件事务内存）
    * 原子变量
    * 代理

* 优势：
    * 并发支持
    * 延迟计算
    * 数据即代码
* 不足：
    * 前缀表达法
    * 可读性
    * 学习曲线




## 第8章 Haskell
一篇对Monad比较简单的说明文章：<br>
[在你身边你左右 --函数式编程别烦恼](https://juejin.im/post/5b26a8b66fb9a00e925bcf30)




## 第9章 落幕时分
* 编程模型：
    * 面向对象（Ruby、Scala）
    * 原型编程（Io）
    * 约束—逻辑编程（Prolog）
    * 函数式编程（Scala、Erlang、Clojure、Haskell）
* 并发：
    * 控制可变状态
    * Io、Erlang和Scala中的actor
    * future
    * 事务型内存
* 编程结构：
    * 列表解析
    * monad
    * 匹配
    * 合一（Prolog可将合法值替换到规则内，从而使规则的左右两边匹配。Prolog会尝试不同的值，直到穷尽所有合法值为止）
