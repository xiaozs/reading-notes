# 《两周自制脚本语言》
## 第1天 来，我们一起做些什么吧
介绍了编译器解析器的区别。

## 第2天 设计程序设计语言
定了一些基础语法。

## 第3天 分割单词
这里用的是正则表达式来分割的单词，<br>
但他把不同的token的正则都放到一起了，显得比较杂乱。<br>
放在一起，然后通过正则的（）功能进行分类提取。<br>
同时提取的过程中会在token类里面保存一些相关的元数据：行号等。<br>
值得注意的是，字符串的token在保存内容的时候，对其进行了操作，让它支持了转义。

## 第4天 用于表示程序的对象
这一章设计了ast（抽象语法树）的数据结构<br>
然后介绍了BNF范式<br>
这里提到了BNF范式的两个特性：
* 可以递归
* 可以通过增加层级来隐含运算优先级

## 第5天 设计语法分析器
主要是用了一个自己写的库来吧BNF转换成为了ast转换器。<br>
库的实现方法要在第17章才会说<br>
另外还有一个对操作符的结合方向做的设置，这个原理也是不明。<br>
还有一个由于设计的语言的的语句可以省略;号，所以在终结符的配置里面可以配置遇到`\n};`这些符号时会截断单词。<br>


## 第6天 通过解释器执行程序
每一个抽象树节点都递归执行eval，最终可以得到一整个树的结果。<br>
值得注意的点是，对赋值语句做了特殊处理，eval函数执行时需要传入一个上下文对象，赋值语句要修改上下文。


## 第7天 添加函数功能

添加了函数功能，和前面的过程差不多。<br>
定义函数就是在上下文上加一个键值对把函数的ast存起来。<br>
由于有一个作用域的问题，所以会在每次执行函数时会生成一个新的作用域，并连接到旧作用域上。<br>
因为定义函数的时候把对应的上下文对象都一起包到函数对象里面了，所以实现闭包很简单。


## 第8天 关联Java语言
简单来说就是在根上下文中注入java的方法，判断是否java函数，然后用反射执行


## 第9天 设计面向对象语言
最主要实现了xx.xx,xx.new这些语法，所谓的类和js很像就是一个构造函数。<br>
xx.new操作其实就是new了一个上线文对象给这个构造函数执行。<br>


## 第10天 无法割舍的数组
这个套路和前面一样。




## 第15天 手工设计词法分析器
介绍了有限自动机和把正则转换成自动机的方法。<br>
先把图画出来，接下来的就很容易了。<br>
把正则的相关操作换成自动机的操作，词法分析器就好了。


## 第16天 语法分析方式
ll算法，采用递归向下分析的方法，实现比较简单，但能力有限。<br>
实现的方法和上一章差不多，都是先通过画图（轨道图），通过轨道图来写程序。<br>
还介绍了ll算法能力有限的原因。<br>

然后是算符优先分析法，是一种自底向上的分析法。（这个我已经看不懂了）


## 第17天 Parser库的内部结构
主要是用了上面两章书的算法，因为用的是ll算法，所以语法规则里面不能有歧义。


## 第18天 GluonJ的使用方法
这个是作者自有的java编译器，没有什么泛用性，就不看了。


## 第19天 抽象语法树与设计模式
这里介绍了3种模式：
* interpreter模式，就是很典型的那种面向对象的方法，通过接口实现大一统，但是添加新方法麻烦。
* visitor模式，这个则非常的函数式，添加新方法容易，但是添加新类很麻烦。
* 然后是面向切面的方法：
    1. 像是本书里面用到的Gluonj，是用一种类似于open Class的方法
    2. minxin
    3. c#的拓展方法