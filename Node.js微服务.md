# 《Node.js微服务》
## 第1章 微服务架构
一些概念的介绍：
* 自然增长：随着业务需求的增长而逐步发展的过程。
* 单块架构：没有对软件组件通过业务关系的紧密度来对业务流进行分离的架构。
* 微服务：指小型的软件组件，每个服务都专职处理某一类任务。
    * 优点：下述
    * 缺点：延迟、可追踪性、配置管理问题、运维负担、最终一致性

* 设计原则：
    1. 参考公司业务再拆分（要求拆分出来的模块要高内聚、低耦合（即一开始就要定义好调用接口））
    2. 是包含业务逻辑，并能采用简单信道、协议与之通信的节点（即使用通用协议）
    3. 去中心化（为了健壮性、弹性、达成最终一致性）

微服务的好处：
* 弹性：系统从异常中恢复的能力
* 可伸缩性：微服务在遇到容量问题（处理任务的能力不足）时，能通过创建更多的微服务实例来解决问题。
* 技术多样式：通过分解成微服务，不同部分可以通过不同技术实现（因为各有所长），并通过通用协议沟通
* 可替换性：这一点是由低耦合保证的，因为实现了接口，所以可以替换实现
* 独立性：接口隔离导致的独立，可以在没有交流的情况下完成开发。
* 易于部署：相较复杂系统更易部署。

## 第2章 基于Seneca和PM2构建Node.js微服务
开头是一些node相关的基础知识。
介绍了一个模块编写模式：
```javascript
// 好处：
// 1. 能向模块传递配置
// 2. 模块参数化，便于mock行为与数据
function init(options) {
    return {
        fun1,
        fun2
    }
}

export init;
```

之后是Seneca库的使用：<br>
Seneca比较有意思的一点是支持多种通用协议，<br>
默认使用的tcp，可以通过插件生成express的中间件以支持http，<br>
内置了一套简单的orm api（配合插件可以无缝切换不同的存储策略（大概吧））<br>
还有就是模式匹配路由，还有请求转发这些功能。

最后是pm2的使用：
* ```pm2 start <appName>```启动应用
* ```pm2 show <id>```获取id对应应用相关信息
* ```pm2 monit```监控应用列表
* ```pm2 logs```查看日志
* ```pm2 reload <appName | all>```无缝重启某个/所有应用
* ```pm2 stop <appName | all>```停止某个/所有应用
* ```pm2 delete <appName | all>```删除某个/所有应用
* ```pm2 start <appName> -i <count>```用集群启动程序
* ```pm2 scale <appName> <count>```修改集群工作线程
* ```pm2 startup```设置pm2为开机自启动服务
* ```pm2 save```保存当前运行的app，开机自启动服务会启动他们

## 第3章 从单块到微服务
介绍了一些微服务设计时相关的原则，特别是要避免过度抽象<br>
（微服务原则是要做小做精，本身就易于测试、重构，考虑过多抽象的情况，反而有害）<br>
其余就是一些老生常谈的：
* 单一职责
* 开闭原则
* 里氏替换
* 接口分离
* 依赖注入

Seneca采用了匹配的方式通过添加新的匹配的模式的方式来添加新的功能，避免了修改原功能，符合了开闭原则。<br>
可以通过插件的形式来引入新的模块，每一个模块符合单一职责（这个和hapi的插件机制、路由机制相似）

微服务的缺陷：
* 维护问题（需要更自动化的维护）
* 不一致性（不同人维护不同的微服务，会导致一些风格上的不一致）
* 提高了复杂度，复杂度带来了安全问题



## 第4章 编写你的第一个Node.js微服务
通过一个简单的demo来展示微服务的编写方法，代码本身比较简单，<br>
主要的内容时体验了之前介绍的架构原则。<br>
一些特殊的原则：
* 服务间的调用如果能够直接调用，就直接调用，通过代理的方式会降低系统的弹性（一点挂了，其他点会更容易受影响）
* 追求极致的灵活性时，可以采用订阅系统来作为微服务间的通信。

服务降级：部分微服务挂了，不会导致整个系统完全失效。

断路器：用于防止请求发送到不稳定（如服务器繁忙导致超时）的服务器上导致失常，防止错误扩散到整个系统<br>
同时断路器会周期性访问服务判断服务是否正常<br>
可以在服务失常时，向工程师发送告警。
* 关闭：请求可以发往目标服务器
* 开启：无法通过断路器，客户端会得到错误信息
* 半开启：对服务进行尝试，如果可以会闭合断路器


Seneca通过插件的方式组织模块<br>
抽象出路由为匹配模式，使得可以通过多种方式调用服务（TCP、HTTP、队列等）<br>
说不定可以抽象为控制器类，用修饰器配置匹配模式的方式实现类似功能。<br>
特有的修饰器作为钩子的标志执行一些初始化、析构之类的操作。




## 第5章 安全性和可追溯性
* 基础设施的逻辑安全
    * SSH
* 应用程序安全
    * 注入：输入验证
    * 跨站脚本攻击：对输出编码
    * 跨站请求伪造：csrf token
    * 开放重定向（被伪造网站利用本站点的重定向跳转到了伪造页面）：禁止用户重定向到未授权的第三方网站。

* 可追溯性
    * 日志：最好在框架api上就做好
    * 请求追踪：每一个请求会有一个唯一ID，日志上所有有同一id的日志都来自同一个请求
* 审计
    * 日志分级：
        * debug：开发、调试中的问题跟踪
        * info：标志重要事件，如事务的开始、结束
        * warn：不严重的不正常行为（用户不受影响）
        * error：错误（用户受影响，流程终止）
        * fatal：灾难（系统不可恢复的错误）
    * HTTP状态码：因为这个是标准，有利于服务间的通用沟通