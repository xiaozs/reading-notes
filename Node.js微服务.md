# 《Node.js微服务》
## 第1章 微服务架构
一些概念的介绍：
* 自然增长：随着业务需求的增长而逐步发展的过程。
* 单块架构：没有对软件组件通过业务关系的紧密度来对业务流进行分离的架构。
* 微服务：指小型的软件组件，每个服务都专职处理某一类任务。
    * 优点：下述
    * 缺点：延迟、可追踪性、配置管理问题、运维负担、最终一致性

* 设计原则：
    1. 参考公司业务再拆分（要求拆分出来的模块要高内聚、低耦合（即一开始就要定义好调用接口））
    2. 是包含业务逻辑，并能采用简单信道、协议与之通信的节点（即使用通用协议）
    3. 去中心化（为了健壮性、弹性、达成最终一致性）

微服务的好处：
* 弹性：系统从异常中恢复的能力
* 可伸缩性：微服务在遇到容量问题（处理任务的能力不足）时，能通过创建更多的微服务实例来解决问题。
* 技术多样式：通过分解成微服务，不同部分可以通过不同技术实现（因为各有所长），并通过通用协议沟通
* 可替换性：这一点是由低耦合保证的，因为实现了接口，所以可以替换实现
* 独立性：接口隔离导致的独立，可以在没有交流的情况下完成开发。
* 易于部署：相较复杂系统更易部署。

## 第2章 基于Seneca和PM2构建Node.js微服务
开头是一些node相关的基础知识。
介绍了一个模块编写模式：
```javascript
// 好处：
// 1. 能向模块传递配置
// 2. 模块参数化，便于mock行为与数据
function init(options) {
    return {
        fun1,
        fun2
    }
}

export init;
```

之后是Seneca库的使用：<br>
Seneca比较有意思的一点是支持多种通用协议，<br>
默认使用的tcp，可以通过插件生成express的中间件以支持http，<br>
内置了一套简单的orm api（配合插件可以无缝切换不同的存储策略（大概吧））<br>
还有就是模式匹配路由，还有请求转发这些功能。

最后是pm2的使用：
* ```pm2 start <appName>```启动应用
* ```pm2 show <id>```获取id对应应用相关信息
* ```pm2 monit```监控应用列表
* ```pm2 logs```查看日志
* ```pm2 reload <appName | all>```无缝重启某个/所有应用
* ```pm2 stop <appName | all>```停止某个/所有应用
* ```pm2 delete <appName | all>```删除某个/所有应用
* ```pm2 start <appName> -i <count>```用集群启动程序
* ```pm2 scale <appName> <count>```修改集群工作线程
* ```pm2 startup```设置pm2为开机自启动服务
* ```pm2 save```保存当前运行的app，开机自启动服务会启动他们

## 第3章 从单块到微服务
介绍了一些微服务设计时相关的原则，特别是要避免过度抽象<br>
（微服务原则是要做小做精，本身就易于测试、重构，考虑过多抽象的情况，反而有害）<br>
其余就是一些老生常谈的：
* 单一职责
* 开闭原则
* 里氏替换
* 接口分离
* 依赖注入

Seneca采用了匹配的方式通过添加新的匹配的模式的方式来添加新的功能，避免了修改原功能，符合了开闭原则。<br>
可以通过插件的形式来引入新的模块，每一个模块符合单一职责（这个和hapi的插件机制、路由机制相似）

微服务的缺陷：
* 维护问题（需要更自动化的维护）
* 不一致性（不同人维护不同的微服务，会导致一些风格上的不一致）
* 提高了复杂度，复杂度带来了安全问题

